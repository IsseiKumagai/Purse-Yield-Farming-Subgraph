// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class UserActions extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserActions entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserActions must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserActions", id.toString(), this);
    }
  }

  static load(id: string): UserActions | null {
    return changetype<UserActions | null>(store.get("UserActions", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userDeposits(): Array<string> {
    let value = this.get("userDeposits");
    return value!.toStringArray();
  }

  set userDeposits(value: Array<string>) {
    this.set("userDeposits", Value.fromStringArray(value));
  }

  get userWithdraws(): Array<string> {
    let value = this.get("userWithdraws");
    return value!.toStringArray();
  }

  set userWithdraws(value: Array<string>) {
    this.set("userWithdraws", Value.fromStringArray(value));
  }

  get userAddNewPools(): Array<string> {
    let value = this.get("userAddNewPools");
    return value!.toStringArray();
  }

  set userAddNewPools(value: Array<string>) {
    this.set("userAddNewPools", Value.fromStringArray(value));
  }

  get userUpdatePoolRewards(): Array<string> {
    let value = this.get("userUpdatePoolRewards");
    return value!.toStringArray();
  }

  set userUpdatePoolRewards(value: Array<string>) {
    this.set("userUpdatePoolRewards", Value.fromStringArray(value));
  }

  get userUpdatePoolMultipliers(): Array<string> {
    let value = this.get("userUpdatePoolMultipliers");
    return value!.toStringArray();
  }

  set userUpdatePoolMultipliers(value: Array<string>) {
    this.set("userUpdatePoolMultipliers", Value.fromStringArray(value));
  }

  get userClaimRewards(): Array<string> {
    let value = this.get("userClaimRewards");
    return value!.toStringArray();
  }

  set userClaimRewards(value: Array<string>) {
    this.set("userClaimRewards", Value.fromStringArray(value));
  }

  get userEmergencyWithdraws(): Array<string> {
    let value = this.get("userEmergencyWithdraws");
    return value!.toStringArray();
  }

  set userEmergencyWithdraws(value: Array<string>) {
    this.set("userEmergencyWithdraws", Value.fromStringArray(value));
  }
}

export class UserDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserDeposit", id.toString(), this);
    }
  }

  static load(id: string): UserDeposit | null {
    return changetype<UserDeposit | null>(store.get("UserDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get amountDeposit(): BigInt {
    let value = this.get("amountDeposit");
    return value!.toBigInt();
  }

  set amountDeposit(value: BigInt) {
    this.set("amountDeposit", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserWithdraw", id.toString(), this);
    }
  }

  static load(id: string): UserWithdraw | null {
    return changetype<UserWithdraw | null>(store.get("UserWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get amountWithdraw(): BigInt {
    let value = this.get("amountWithdraw");
    return value!.toBigInt();
  }

  set amountWithdraw(value: BigInt) {
    this.set("amountWithdraw", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserAddNewPool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAddNewPool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserAddNewPool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserAddNewPool", id.toString(), this);
    }
  }

  static load(id: string): UserAddNewPool | null {
    return changetype<UserAddNewPool | null>(store.get("UserAddNewPool", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get lpTokenPoolAddress(): Bytes {
    let value = this.get("lpTokenPoolAddress");
    return value!.toBytes();
  }

  set lpTokenPoolAddress(value: Bytes) {
    this.set("lpTokenPoolAddress", Value.fromBytes(value));
  }

  get amountTokenPerBlock(): BigInt {
    let value = this.get("amountTokenPerBlock");
    return value!.toBigInt();
  }

  set amountTokenPerBlock(value: BigInt) {
    this.set("amountTokenPerBlock", Value.fromBigInt(value));
  }

  get numberBonusMultiplier(): BigInt {
    let value = this.get("numberBonusMultiplier");
    return value!.toBigInt();
  }

  set numberBonusMultiplier(value: BigInt) {
    this.set("numberBonusMultiplier", Value.fromBigInt(value));
  }

  get numberStartBlock(): BigInt {
    let value = this.get("numberStartBlock");
    return value!.toBigInt();
  }

  set numberStartBlock(value: BigInt) {
    this.set("numberStartBlock", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserUpdatePoolReward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserUpdatePoolReward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserUpdatePoolReward must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserUpdatePoolReward", id.toString(), this);
    }
  }

  static load(id: string): UserUpdatePoolReward | null {
    return changetype<UserUpdatePoolReward | null>(
      store.get("UserUpdatePoolReward", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get lpTokenPoolAddress(): Bytes {
    let value = this.get("lpTokenPoolAddress");
    return value!.toBytes();
  }

  set lpTokenPoolAddress(value: Bytes) {
    this.set("lpTokenPoolAddress", Value.fromBytes(value));
  }

  get amountTokenPerBlock(): BigInt {
    let value = this.get("amountTokenPerBlock");
    return value!.toBigInt();
  }

  set amountTokenPerBlock(value: BigInt) {
    this.set("amountTokenPerBlock", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserUpdatePoolMultiplier extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save UserUpdatePoolMultiplier entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserUpdatePoolMultiplier must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserUpdatePoolMultiplier", id.toString(), this);
    }
  }

  static load(id: string): UserUpdatePoolMultiplier | null {
    return changetype<UserUpdatePoolMultiplier | null>(
      store.get("UserUpdatePoolMultiplier", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get lpTokenPoolAddress(): Bytes {
    let value = this.get("lpTokenPoolAddress");
    return value!.toBytes();
  }

  set lpTokenPoolAddress(value: Bytes) {
    this.set("lpTokenPoolAddress", Value.fromBytes(value));
  }

  get numberBonusMultiplier(): BigInt {
    let value = this.get("numberBonusMultiplier");
    return value!.toBigInt();
  }

  set numberBonusMultiplier(value: BigInt) {
    this.set("numberBonusMultiplier", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserClaimReward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserClaimReward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserClaimReward must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserClaimReward", id.toString(), this);
    }
  }

  static load(id: string): UserClaimReward | null {
    return changetype<UserClaimReward | null>(store.get("UserClaimReward", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get pendingAmount(): BigInt {
    let value = this.get("pendingAmount");
    return value!.toBigInt();
  }

  set pendingAmount(value: BigInt) {
    this.set("pendingAmount", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class UserEmergencyWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save UserEmergencyWithdraw entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserEmergencyWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserEmergencyWithdraw", id.toString(), this);
    }
  }

  static load(id: string): UserEmergencyWithdraw | null {
    return changetype<UserEmergencyWithdraw | null>(
      store.get("UserEmergencyWithdraw", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get lpTokenPoolAddress(): Bytes {
    let value = this.get("lpTokenPoolAddress");
    return value!.toBytes();
  }

  set lpTokenPoolAddress(value: Bytes) {
    this.set("lpTokenPoolAddress", Value.fromBytes(value));
  }

  get totalAmountWithdraw(): BigInt {
    let value = this.get("totalAmountWithdraw");
    return value!.toBigInt();
  }

  set totalAmountWithdraw(value: BigInt) {
    this.set("totalAmountWithdraw", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}
